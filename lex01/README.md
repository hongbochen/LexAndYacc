   lex和yacc可以帮助你编写程序转换结构化输入。既包括从输入文件中寻找模式的简单文本搜索程序，也包括将源程序变换为最佳的目标代码的C编译程序等。
    ​lex使用一系列对可能标记的描述，产生一个能识别那些标记的C例程（我们成为词法分析器。词法分析程序（lexer），或成为扫描程序）。
    ​lex使用的标记描述称为正则表达式。yacc采用简明的语法描述并产生在一个能分析语法的C例程。即分析程序。yacc分析程序自动检测输入的标记序列是否匹配语法中的某条规则，并且一旦输入不匹配任一条规则，他就会检测语法错误。
  最简单的lex程序
```
​%%
	​.|\n    ​ECHO
​%%
```
   ​将它的标准输入拷贝到标准输出。

   ​用lex识别单词
   ​构建一个识别不同类型英语单词的简单程序。识别动词和非动词
    ​
```
%{
	/**
	 * 这个例子演示了非常简单的识别
	 * 动词/非动词
	 */

	/**
	 * {% %}为定义部分，定义一个段，介绍了将拷贝到最终程序中的
	 * 原始C程序代码。也就是说这一部分的内容C程序里面是可以使用
	 * 的。如果有后来文件中必须包含的头文件，那么也需要在这里面
	 * 包含。其中，{% %}里面的内容使用C实现，lex将其中的内容直接
	 * 拷贝到生成的C文件。
	 *
	 * lex中的注释必须使用空白符缩进来正确标识，否则将会被lex
	 * 解释成别的东西。
	 * 后面的%%标记这一部分结束
	 * 下面一部分是规则段，每个规则都有两部分组成，模式和动作，
	 * 由空白分开。当lex生成的词法分析程序识别出某个模式时，将
	 * 执行相应的动作，其中模式是unix样式的正则表达式
	 */

	/**
	 * 规则"|"表示下一个模式应用相同的动作，因此所有的
	 * 动词都使用为最后一个动词指定的动作
	 *
	 * island为什么不匹配is而是匹配island或者是两者都匹配呢？
	 *
	 * yytext数组包含匹配模式的文本
 	 * lex有一套简单的消除歧义规则：
	 * 1：lex模式只匹配输入字符或字符串一次
	 * 2：lex执行当前输入的最长可能匹配的动作。
	 * 因为lsland是比is长的匹配u，所以lex把island
	 * 来看做匹配上面那条“包括一切”的规则
	 *
	 * 最后一行是默认情况语句。"."匹配换行符意外的任意单个字符，
	 * "\n"匹配一个换行符，ECHO输出匹配的模式。
	 *
	 * 最后部分是用户子例程序，有任意合法的C代码组成。
 	 * 
	 * 使用命令进行编译
 	 * lex simple.lex  //生成lex.yy.c
	 * gcc lex.yy.c -o simple
	 *
	 */
%}

%%
[\t ]+	/* 忽略空白 */;
is |
am |
are |
were |
was |
be |
being |
been |
do |
does |
did |
will |
would |
should |
can |
could |
has |
have |
had |
go	{printf("%s : is a verb\n",yytext);}

[a-zA-Z]+	{printf("%s: is not a verb\n",yytext);}

.|\n	{ECHO; /* 通常的默认状态 */}
%%

int main()
{
	yylex();
	return 0;
}
​
//必须要包含的函数
int yywrap()
{
	return 1;
}

```
下面是我的程序的运行结果：

![这里写图片描述](http://img.blog.csdn.net/20150505100517011)
